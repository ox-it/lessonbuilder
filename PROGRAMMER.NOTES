These notes describe cases where there have been changes in
representation. The results might otherwise be confusing.

CHANGE IN FUNCTION OF PARENT and TOP FIELDS IN SIMPLEPAGE

In the pages (SimplePage), there are two fields that are no longer
used: parent and top. The original design was for pages and subpages,
i.e. a strict hiearchy of pages. Thus pages have the ID number of
their parent and the top level page for their tool.

However I've moved to a general mesh of pages. So those fields no
longer mean much. They are only actually used to tell which pages are
top-level, in the sense of being the top page for their tool (where a
tool is something in the left margin). Pages that are top level has 
a null parent. At this point I'm using an ID number of 0 for the parent
of everything else.

The way pages now work is that each is pretty much independent. What
differentiates a subpage is its main page has an item of type PAGE
that points to it. The same page can actually be pointed to from
several different places.

There's a notional site-wide page which is the parent of all the
top-level pages. So each top-level page has an item that points to it.
These are the items that would appear in the site-wide page if it
existed.

I actually had a sort of embarrassing bug. Since the code for copying
pages assumed a hierarchy, it just did a recursive descent. The first
time in the new structure I had two pages pointing to each other, that
code blew the stack. At this point the export files don't have any
hierarchy in them. They start with a list of pages, and then for each
page the items in it. When something is a subpage that fact shows
because there's an item in another page pointing to it. This
generality means that I have to generate all the pages in the new
site, making on a hash table from old ID number to new ID number. Then
I go back and fill in the items. When one of the items is another
page, I use the hash table to find the ID number in the new site. I
can still read old export files, but I ignore the hierarchical
structure in them.

HOW LESSON BUILDER PAGES CONNECT TO THE REST OF SAKAI

Sakai is organized into tools and pages. A page is something in
the left margin. Each page can have more than one tool on it.
For Lesson Builder that would be unusual. Page in this context
is a Sakai page. It has nothing to do with Lesson Builder pages.
I refer to it as "site page" in the few pages in the code where it
appears.

To find the top level page for a tool, we look for a page that has the
right toolID and a parent page ID that is null. As noted above, at
this point all the parent page ID is used for is identifying top level
pages by the fact that their parent is null. toolid's used to be used
for all pages, but since pages can now move around, only the top-level
page is currently associated with a tool. Thus the toolId field in
SimplePage is really only useful for parent==null.

Note that when you create a new instance of Lesson Builder, it makes a
site page and tool, but doesn't create any Lesson Builder entities at
all. The first time the tool is invoked, ShowPageProducer is called.
Normally ShowPageProducer is passed an argument of SendingPage to tell
it what page to go to. But when Sakai calls SHowPageProducer,
obviously there's no such argument, since Sakai knows nothing about
Lesson Builder's structures. So when ShowPageProducer isn't passed a
sendingpage, SimplePageBean.getCurrentPageId will note this fact, and
ask the Sakai session manager to find the current Sakai tool. It will
then locate the top level page for that tool by looking for a page
with nulll parent and the right tool ID.

If this is the first time ShowPageProducer has been called for this
tool, SimplePageBean will create the top-level page, and also the
top-level item pointing to it from the notional (but non-existent)
root page.

CHANGE IN FORMAT OF SAKAIID in ITEMS

Items have a type and a SakeiId. Originally the type was something
like SmplePageItem.ASSIGNMENT and the SakaiID was the assignment ID
number. However the moment we got to more than one assignment tool,
this wasn't the right approach. SakaiId needs to be a reference, e.g.
"/assignment/ID" or "/assignment2/ID". So the item type is the generic
type e.g. assignment, but actual implementation type (assignment of
assignment 2) is in the reference. 

Newly created items will all use the reference format. However old
database entries may not. So if we find a SakaiID that is a simple
number, we assume it's a reference to the primary tool of that type
(i.e. Assignment, Samigo, or jForum).

Note that there's another special SakaiID, SimplePageItem.DUMMY. This
is used for dummy references. When you copy a site, we can't copy the
actual references to test, assignment, etc (because of issues in how
the copy code works). So we produce dummy references. The display code
knows to display them with a note telling the author to choose an
actual test, assignment, etc.

THE URL ITEM TYPE

There's a URL type. Currently I'm not using it. When an item refers to
a URL, I actually create a URL item in Resources. So it looks like any
other resource. This may be a mistake. I've considered going back and
using raw URL's. The main reason I haven't is that this approach
causes all access to go through Resources, so Event log entries are
made, and I have the potential for doing access control in resources
if I ever want to.

NAMES INVOLVING SIMPLEPAGE

You'll see some class names starting with SimplePage. This started out
as a copy of the SimplePage tool. All the database tables and
everything else external were updated, but we didn't have time to go
back and fix up all the code.

